# Подробный анализ пакета hlc (Hybrid Logical Clock)

## Оглавление
1. [Обзор пакета](#обзор-пакета)
2. [Концепция Hybrid Logical Clock](#концепция-hybrid-logical-clock)
3. [Структуры данных](#структуры-данных)
4. [Основные компоненты](#основные-компоненты)
5. [Методы и функции](#методы-и-функции)
6. [Примеры использования](#примеры-использования)
7. [Технические детали](#технические-детали)

---

## Обзор пакета

Пакет `hlc` реализует **Hybrid Logical Clock** (HLC) - гибридные логические часы с генерацией уникальных идентификаторов (TID). Это распределенная система временных меток, которая сочетает физическое время (Physical Time) с логическим счетчиком для обеспечения каузального упорядочивания событий в распределенных системах.

### Основное назначение:
- **Упорядочивание событий** в распределенных системах без необходимости синхронизации физических часов
- **Генерация уникальных идентификаторов** (TID), совместимых с AT Protocol
- **Обнаружение каузальных связей** между событиями
- **Защита от расхождения часов** (clock drift) между узлами

### Ключевые возможности:
- Thread-safe операции (защита мутексом)
- Настраиваемые параметры (node ID, max drift)
- Совместимость с AT Protocol для TID
- Сериализация/десериализация временных меток
- Base32 кодирование для читаемости идентификаторов

---

## Концепция Hybrid Logical Clock

### Что такое HLC?

HLC объединяет преимущества двух подходов:

1. **Physical Time (PT)** - реальное физическое время в микросекундах с Unix epoch
   - Позволяет приблизительно определить реальное время события
   - Используется как основа для упорядочивания

2. **Logical Counter (LC)** - логический счетчик
   - Инкрементируется при событиях в одну микросекунду
   - Гарантирует уникальность и порядок событий даже при одинаковом PT

### Зачем это нужно?

В распределенных системах возникают проблемы:
- **Часы на разных узлах идут по-разному** (clock drift)
- **Сложно определить порядок событий**, произошедших на разных серверах
- **Невозможно полагаться только на физическое время** из-за отставания/опережения часов

HLC решает эти проблемы, обеспечивая:
- ✅ Монотонность (метки всегда растут)
- ✅ Каузальность (если A → B, то timestamp(A) < timestamp(B))
- ✅ Близость к реальному времени (PT остается близким к wall clock)

---

## Структуры данных

### 1. Clock - Основной тип HLC

```go
type Clock struct {
    mu      sync.Mutex     // Мутекс для thread-safety
    maxDiff time.Duration  // Максимально допустимое расхождение часов
    pt      uint64         // Physical time в микросекундах
    lc      uint16         // Logical counter (0-65535)
    node    uint16         // Node ID для уникальности (10 бит: 0-1023)
    now     func() uint64  // Функция получения текущего времени
}
```

**Назначение полей:**

- **mu**: Защищает от конкурентного доступа. Все публичные методы захватывают мутекс
- **maxDiff**: Предел для обнаружения "часов из будущего". По умолчанию 1 минута
- **pt**: Хранит максимальное известное физическое время (в микросекундах с 1970-01-01)
- **lc**: Счетчик событий в одну микросекунду. Сбрасывается при изменении pt
- **node**: 10-битный идентификатор узла (0-1023), используется в TID для уникальности
- **now**: Инжектируемая функция времени (для тестирования можно подменить)

### 2. Timestamp - Метка времени HLC

```go
type Timestamp struct {
    PT uint64  // Physical time (микросекунды с epoch)
    LC uint16  // Logical counter
}
```

**Назначение:**
- Представляет точку во времени с точностью до микросекунды + логический порядок
- Используется для упорядочивания событий
- Может быть сериализована в 10 байт (8 + 2)

**Пример значения:**
```
PT: 1701360000000000  // 30 ноября 2023, 12:00:00 UTC
LC: 5                 // Пятое событие в эту микросекунду
```

### 3. TID - Timestamp Identifier

```go
type TID uint64
```

**Структура битов (64 бита):**
```
┌─────────────────────────────────────────────────────┬──────────────┬─┐
│         Physical Time (53 бита)                     │ Node (10 бит)│R│
│         Timestamp в микросекундах                   │   ID узла    │0│
└─────────────────────────────────────────────────────┴──────────────┴─┘
 63                                                  11 10           1 0
```

**Разбивка:**
- **Биты 63-11 (53 бита)**: Физическое время в микросекундах
  - Позволяет представить ~285 лет времени
- **Биты 10-1 (10 бит)**: Node ID (0-1023)
  - Идентификатор узла для уникальности
- **Бит 0 (1 бит)**: Reserved (зарезервирован, всегда 0)

**Зачем TID?**
- Совместимость с AT Protocol (Authenticated Transfer Protocol)
- Глобально уникальные идентификаторы для записей
- Сортируемость по времени создания
- Компактное представление (8 байт или 13 символов в base32)

---

## Основные компоненты

### Константы и ошибки

```go
var (
    ErrClockDrift = errors.New("clock drift too large")
    ErrFuture     = errors.New("timestamp too far in future")
    ErrInvalidTID = errors.New("invalid tid")
)

const base32Alphabet = "234567abcdefghijklmnopqrstuvwxyz"
```

**ErrClockDrift**: Возвращается, когда разница между часами превышает maxDiff

**ErrFuture**: Полученная метка времени слишком далеко в будущем (> now + maxDiff)

**ErrInvalidTID**: Ошибка парсинга TID (неверная длина или символы)

**base32Alphabet**: Кастомный алфавит для base32 кодирования:
- Исключены: 0, 1, 8, 9, O, I, L (похожие символы)
- Используются: 2-7 и a-z (кроме исключенных)
- Сортируемость: лексикографический порядок = хронологический порядок

---

## Методы и функции

### Создание и конфигурация Clock

#### New() - Создание новых часов

```go
func New() *Clock
```

**Что делает:**
1. Генерирует случайный Node ID (10 бит) с помощью crypto/rand
2. Инициализирует maxDiff = 1 минута
3. Устанавливает now() = текущее время системы
4. PT и LC начинаются с 0 (устанавливаются при первом вызове Now())

**Пример:**
```go
clk := hlc.New()  // Node ID случайный, например 583
```

**Зачем случайный Node ID?**
- Избежать конфликтов при автоматическом развертывании
- Не требуется централизованное распределение ID
- 10 бит дают 1024 возможных значения (достаточно для большинства кластеров)

#### WithNodeID() - Установка фиксированного Node ID

```go
func (c *Clock) WithNodeID(id uint16) *Clock
```

**Назначение:**
- Установить конкретный ID узла (0-1023)
- Полезно для персистентных узлов с фиксированной топологией
- Маскируется с 0x03FF для гарантии 10 бит

**Пример:**
```go
clk := hlc.New().WithNodeID(42)  // Узел с ID=42
```

#### WithMaxDrift() - Настройка допустимого расхождения

```go
func (c *Clock) WithMaxDrift(d time.Duration) *Clock
```

**Назначение:**
- Установить максимально допустимое отклонение часов
- По умолчанию: 1 минута
- Защита от сильно рассинхронизированных узлов

**Пример:**
```go
clk := hlc.New().WithMaxDrift(5 * time.Minute)
```

**Выбор maxDrift:**
- Слишком маленькое значение → много ложных отказов при небольших расхождениях
- Слишком большое → допускает сильно рассинхронизированные узлы
- Рекомендуется: 1-5 минут для локальной сети, до 10 минут для WAN

---

### Генерация временных меток

#### Now() - Генерация новой Timestamp

```go
func (c *Clock) Now() Timestamp
```

**Алгоритм:**
```
1. Получить текущее физическое время: now = time.Now().UnixMicro()
2. Захватить мутекс
3. Если now > c.pt:
     → Часы продвинулись вперед
     → c.pt = now
     → c.lc = 0 (сброс логического счетчика)
   Иначе:
     → Событие в ту же микросекунду
     → c.lc++ (инкремент логического счетчика)
4. Вернуть Timestamp{PT: c.pt, LC: c.lc}
```

**Пример выполнения:**
```go
clk := hlc.New()

ts1 := clk.Now()  // PT=1701360000000000, LC=0
ts2 := clk.Now()  // PT=1701360000000000, LC=1 (та же микросекунда)
time.Sleep(2 * time.Microsecond)
ts3 := clk.Now()  // PT=1701360000000002, LC=0 (время увеличилось)
```

**Важные свойства:**
- ✅ Монотонность: каждый последующий вызов дает больший Timestamp
- ✅ Thread-safe: мутекс защищает от гонок
- ✅ LC сбрасывается при смене PT

#### TID() - Генерация уникального идентификатора

```go
func (c *Clock) TID() TID
```

**Алгоритм:**
```
1. Обновить PT и LC (аналогично Now())
2. Закодировать в 64-битный TID:
   TID = (c.pt << 11) | (c.node << 1) | 0
        └─────┬─────┘   └────┬────┘    └┬┘
          53 бита        10 бит      reserved
          timestamp      node ID
```

**Пример битовой структуры:**
```
PT   = 1701360000000000 (0x60B3A2F8D0000)
Node = 42 (0x2A)

TID = (1701360000000000 << 11) | (42 << 1) | 0
    = 3485497344000000000 | 84 | 0
    = 0x306D5179D6800054
```

**String представление:**
```go
tid := clk.TID()
str := tid.String()  // "abcdefghijklm" (13 символов base32)
```

---

### Синхронизация с другими узлами

#### Update() - Обновление при получении сообщения

```go
func (c *Clock) Update(received Timestamp) (Timestamp, error)
```

**Назначение:**
Обновить локальные часы при получении метки времени от другого узла. Это ключевой метод для синхронизации распределенных часов.

**Алгоритм:**
```
1. Получить текущее время: now = time.Now().UnixMicro()
2. Проверить на "часы из будущего":
   Если received.PT > now + maxDiff:
     → Вернуть ErrFuture (метка слишком далеко в будущем)

3. Выбрать максимальное PT:

   a) Если now > c.pt И now > received.PT:
      → Локальное время самое свежее
      → c.pt = now
      → c.lc = 0

   b) Если c.pt == received.PT:
      → Та же микросекунда
      → c.lc = max(c.lc, received.LC)
      → c.lc++  (новое событие)

   c) Если received.PT > c.pt:
      → Полученная метка новее
      → c.pt = received.PT
      → c.lc = received.LC + 1

   d) Иначе (c.pt > received.PT):
      → Наше PT больше
      → c.lc++

4. Вернуть новый Timestamp{PT: c.pt, LC: c.lc}
```

**Пример сценария:**

```go
clkA := hlc.New().WithNodeID(1)
clkB := hlc.New().WithNodeID(2)

// Узел A генерирует событие
ts1 := clkA.Now()  // {PT: 1000, LC: 0}

// Узел B получает сообщение от A
ts2, _ := clkB.Update(ts1)  // {PT: 1000, LC: 1}

// Узел B генерирует событие
ts3 := clkB.Now()  // {PT: 1000, LC: 2} (если в ту же μs)
```

**Каузальные связи:**
```
A: event1 → ts1 → отправка сообщения
                        ↓
B:                   получение → Update(ts1) → ts2 → event2

Гарантия: ts1 < ts2
Значит: event1 произошло раньше event2 (причинно-следственная связь)
```

#### UpdateTID() - Обновление из TID

```go
func (c *Clock) UpdateTID(tid TID) (TID, error)
```

**Что делает:**
1. Извлекает Timestamp из полученного TID
2. Вызывает Update() для синхронизации
3. Создает новый TID с обновленным Timestamp и своим Node ID

**Пример:**
```go
// Узел A генерирует TID
tidA := clkA.TID()  // TID с Node=1

// Узел B получает TID от A
tidB, _ := clkB.UpdateTID(tidA)  // Новый TID с Node=2, но PT >= tidA.PT
```

---

### Вспомогательные методы Clock

#### Timestamp() - Чтение без изменений

```go
func (c *Clock) Timestamp() Timestamp
```

**Назначение:**
- Получить текущее значение часов **без инкремента**
- Используется для чтения состояния (например, для логирования)
- Thread-safe (захватывает мутекс)

#### Set() - Восстановление из хранилища

```go
func (c *Clock) Set(ts Timestamp) error
```

**Назначение:**
- Восстановить состояние часов из персистентного хранилища
- Проверяет, что ts.PT не слишком далеко в будущем
- Используется при перезапуске сервера

**Пример использования:**
```go
// При остановке сервера
ts := clk.Timestamp()
saveToDatabase(ts)  // Сохранить в БД

// При запуске сервера
clk := hlc.New()
ts := loadFromDatabase()
clk.Set(ts)  // Восстановить состояние
```

**Зачем это нужно?**
- Избежать генерации меток времени "из прошлого" после перезапуска
- Сохранить монотонность часов

#### NodeID() - Получение ID узла

```go
func (c *Clock) NodeID() uint16
```

**Назначение:**
- Получить текущий Node ID (для логирования, мониторинга)

---

## Методы Timestamp

### Compare() - Сравнение временных меток

```go
func (a Timestamp) Compare(b Timestamp) int
```

**Алгоритм:**
```
1. Сравнить PT:
   Если a.PT < b.PT → вернуть -1
   Если a.PT > b.PT → вернуть 1

2. PT равны, сравнить LC:
   Если a.LC < b.LC → вернуть -1
   Если a.LC > b.LC → вернуть 1

3. Оба поля равны → вернуть 0
```

**Вспомогательные методы:**
```go
func (a Timestamp) Before(b Timestamp) bool  // a < b
func (a Timestamp) After(b Timestamp) bool   // a > b
func (a Timestamp) Equal(b Timestamp) bool   // a == b
func (ts Timestamp) IsZero() bool            // ts == {0, 0}
```

### Time() - Преобразование в time.Time

```go
func (ts Timestamp) Time() time.Time
```

**Назначение:**
- Получить физическое время как стандартный Go time.Time
- Теряется информация о LC (логический счетчик)
- Точность: микросекунды

**Пример:**
```go
ts := clk.Now()
t := ts.Time()
fmt.Println(t.Format(time.RFC3339Nano))
// Вывод: 2023-11-30T12:00:00.000000Z
```

### Marshal() / UnmarshalTimestamp() - Сериализация

```go
func (ts Timestamp) Marshal() []byte
func UnmarshalTimestamp(b []byte) (Timestamp, error)
```

**Формат (10 байт):**
```
┌──────────────────┬──────────┐
│  PT (8 байт)     │ LC (2)   │
│  Big Endian      │Big Endian│
└──────────────────┴──────────┘
```

**Пример:**
```go
ts := Timestamp{PT: 1701360000000000, LC: 42}
data := ts.Marshal()  // [0x60, 0xB3, 0xA2, 0xF8, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x2A]

restored, _ := hlc.UnmarshalTimestamp(data)
// restored == ts
```

**Использование:**
- Сохранение в БД
- Передача по сети (бинарный протокол)
- Компактность: 10 байт vs 24+ байт в JSON

---

## Методы TID

### Timestamp() - Извлечение временной метки

```go
func (t TID) Timestamp() Timestamp
```

**Алгоритм:**
```
PT = (TID >> 11)  // Извлечь верхние 53 бита
LC = 0            // LC не хранится в TID
```

**Ограничение:**
- TID не сохраняет LC, только PT и Node ID
- Точность восстановления: до микросекунды

### NodeID() - Извлечение ID узла

```go
func (t TID) NodeID() uint16
```

**Алгоритм:**
```
NodeID = (TID >> 1) & 0x03FF  // Биты 10-1
```

### Time() - Время создания TID

```go
func (t TID) Time() time.Time
```

**Назначение:**
- Получить физическое время создания TID
- Аналог Timestamp().Time()

### String() - Кодирование в base32

```go
func (t TID) String() string
```

**Алгоритм:**
```
1. Создать буфер на 13 символов
2. Для каждого 5-битного блока (начиная со старших):
   - Извлечь 5 бит: (tid >> (i*5)) & 0x1F
   - Преобразовать в символ base32Alphabet
3. Вернуть строку
```

**Пример:**
```go
tid := clk.TID()
str := tid.String()
// Вывод: "7ksdn8tqfmkpy"

// Свойства:
// - Длина: всегда 13 символов
// - Сортируемость: лексикографический порядок = хронологический
// - URL-safe: можно использовать в URL без кодирования
```

### ParseTID() - Парсинг из строки

```go
func ParseTID(s string) (TID, error)
```

**Алгоритм:**
```
1. Проверить длину == 13
2. Для каждого символа:
   - Найти индекс в base32Alphabet
   - Если не найден → ErrInvalidTID
   - Сдвинуть результат на 5 бит влево
   - Добавить индекс
3. Вернуть TID
```

**Пример:**
```go
tid, err := hlc.ParseTID("7ksdn8tqfmkpy")
if err != nil {
    // Обработка ошибки
}
```

### Bytes() / TIDFromBytes() - Бинарное представление

```go
func (t TID) Bytes() []byte
func TIDFromBytes(b []byte) (TID, error)
```

**Формат (8 байт):**
```
Big Endian uint64
```

**Использование:**
- Хранение в БД (более компактно, чем строка)
- Бинарные протоколы

---

## Утилиты для работы с диапазонами

### TIDFromTime() - TID из времени

```go
func TIDFromTime(t time.Time, nodeID uint16) TID
```

**Назначение:**
- Создать TID для заданного времени и Node ID
- Используется для запросов по временным диапазонам

**Пример:**
```go
// Найти все записи за 30 ноября 2023
start := time.Date(2023, 11, 30, 0, 0, 0, 0, time.UTC)
tidStart := hlc.TIDFromTime(start, 0)
```

### TIDRange() - Границы диапазона

```go
func TIDRange(from, to time.Time) (TID, TID)
```

**Назначение:**
- Получить минимальный и максимальный TID для временного диапазона
- from → Node ID = 0 (минимальный TID)
- to → Node ID = 1023 (максимальный TID)

**Пример SQL запроса:**
```go
from := time.Date(2023, 11, 30, 0, 0, 0, 0, time.UTC)
to := time.Date(2023, 11, 30, 23, 59, 59, 999999, time.UTC)

tidMin, tidMax := hlc.TIDRange(from, to)

// SELECT * FROM events WHERE tid >= tidMin AND tid <= tidMax
db.Query("SELECT * FROM events WHERE tid BETWEEN ? AND ?", tidMin, tidMax)
```

**Почему Node ID = 0 и 1023?**
- Node ID = 0: минимальный возможный TID для данного времени
- Node ID = 1023: максимальный возможный TID для данного времени
- Гарантирует, что диапазон покрывает все TID в указанный период

---

## Примеры использования

### 1. Простая генерация временных меток

```go
package main

import (
    "fmt"
    "internal/hlc"
)

func main() {
    // Создать часы
    clk := hlc.New()

    // Сгенерировать метки времени
    ts1 := clk.Now()
    ts2 := clk.Now()
    ts3 := clk.Now()

    fmt.Println("ts1:", ts1.PT, ts1.LC)  // PT=X, LC=0
    fmt.Println("ts2:", ts2.PT, ts2.LC)  // PT=X, LC=1
    fmt.Println("ts3:", ts3.PT, ts3.LC)  // PT=X, LC=2

    // Проверить упорядочивание
    fmt.Println("ts1 < ts2:", ts1.Before(ts2))  // true
    fmt.Println("ts2 < ts3:", ts2.Before(ts3))  // true
}
```

### 2. Распределенная синхронизация

```go
// Узел A
clkA := hlc.New().WithNodeID(1)
ts1 := clkA.Now()

// Сериализовать и отправить
data := ts1.Marshal()
sendToNodeB(data)

// --- Сеть ---

// Узел B
clkB := hlc.New().WithNodeID(2)
received, _ := hlc.UnmarshalTimestamp(data)

// Синхронизировать часы
ts2, err := clkB.Update(received)
if err != nil {
    log.Fatal("Clock sync error:", err)
}

// Теперь ts2 гарантированно > ts1
fmt.Println("Causality preserved:", ts2.After(ts1))  // true
```

### 3. Генерация уникальных ID для записей

```go
type Post struct {
    ID      hlc.TID
    Author  string
    Content string
}

func createPost(clk *hlc.Clock, author, content string) Post {
    return Post{
        ID:      clk.TID(),
        Author:  author,
        Content: content,
    }
}

func main() {
    clk := hlc.New()

    post1 := createPost(clk, "alice", "Hello!")
    post2 := createPost(clk, "bob", "Hi there!")

    fmt.Println("Post 1 ID:", post1.ID.String())  // "7ksdn8tqfmkpy"
    fmt.Println("Post 2 ID:", post2.ID.String())  // "7ksdn8tqfmkqz"

    // ID сортируются в хронологическом порядке
    fmt.Println("Chronological:", post1.ID.Before(post2.ID))  // true
}
```

### 4. Запросы по временным диапазонам

```go
import "time"

func getPostsForDay(db *sql.DB, date time.Time) ([]Post, error) {
    // Определить границы дня
    start := time.Date(date.Year(), date.Month(), date.Day(), 0, 0, 0, 0, time.UTC)
    end := start.Add(24 * time.Hour)

    // Получить TID диапазон
    tidMin, tidMax := hlc.TIDRange(start, end)

    // Запрос к БД
    rows, err := db.Query(`
        SELECT id, author, content
        FROM posts
        WHERE id >= ? AND id < ?
        ORDER BY id
    `, tidMin, tidMax)

    // ... обработка результатов
}
```

### 5. Персистентность состояния

```go
type Server struct {
    clk *hlc.Clock
    db  *Database
}

func (s *Server) Shutdown() error {
    // Сохранить состояние часов
    ts := s.clk.Timestamp()
    data := ts.Marshal()
    return s.db.Save("clock_state", data)
}

func (s *Server) Start() error {
    s.clk = hlc.New()

    // Восстановить состояние
    data, err := s.db.Load("clock_state")
    if err == nil {
        ts, _ := hlc.UnmarshalTimestamp(data)
        s.clk.Set(ts)
    }

    return nil
}
```

### 6. Обнаружение каузальных связей

```go
func detectCausality(ts1, ts2 hlc.Timestamp) string {
    if ts1.Before(ts2) {
        return "ts1 → ts2 (ts1 caused ts2)"
    } else if ts2.Before(ts1) {
        return "ts2 → ts1 (ts2 caused ts1)"
    } else {
        return "concurrent events (no causal relation)"
    }
}

// Пример
tsA := clkA.Now()
tsB, _ := clkB.Update(tsA)  // B получил метку от A

fmt.Println(detectCausality(tsA, tsB))
// Вывод: "ts1 → ts2 (ts1 caused ts2)"
```

---

## Технические детали

### Thread Safety

Все публичные методы Clock защищены мутексом:
- `Now()`, `TID()`, `Update()`, `UpdateTID()`: захватывают `mu` на все время работы
- `Timestamp()`, `Set()`, `NodeID()`: также thread-safe

**Важно:**
- Методы Timestamp и TID thread-safe **не требуют**, т.к. это immutable значения
- Clock можно безопасно использовать из нескольких горутин

### Производительность

**Оптимизации:**
- Мутекс держится минимальное время
- `now()` вызывается один раз за операцию
- Нет аллокаций в hot path (кроме Marshal/String)

**Бенчмарки (оценочно):**
- `Now()`: ~50 нс (захват мутекса + инкремент)
- `TID()`: ~60 нс (то же + битовые операции)
- `Update()`: ~100 нс (проверки + синхронизация)

### Ограничения

1. **Максимальное время:**
   - 53 бита для PT → 2^53 микросекунд ≈ 285 лет
   - Начало отсчета: Unix epoch (1970-01-01)
   - Переполнение: ~2255 год

2. **Максимум событий в микросекунду:**
   - LC: 16 бит → 65536 событий/μs
   - Если превышено: потеря точности (PT увеличится на 1 μs)

3. **Количество узлов:**
   - 10 бит Node ID → 1024 узла (0-1023)
   - Для больших кластеров: нужна модификация формата

4. **Clock drift:**
   - Зависит от настройки maxDrift
   - Рекомендуется использовать NTP для минимизации расхождений

### Совместимость с AT Protocol

TID совместим с [AT Protocol](https://atproto.com/specs/record-key#record-key-type-tid) (Bluesky):
- Формат: 64-битный идентификатор
- Кодирование: base32 (13 символов)
- Сортируемость: лексикографический = хронологический
- Уникальность: timestamp + node ID

**Пример использования в AT Protocol:**
```go
// Создать запись с TID ключом
tid := clk.TID()
recordKey := tid.String()  // "7ksdn8tqfmkpy"

// URI: at://did:plc:xyz/app.bsky.feed.post/7ksdn8tqfmkpy
uri := fmt.Sprintf("at://%s/%s/%s", did, collection, recordKey)
```

### Сравнение с альтернативами

| Подход | Плюсы | Минусы |
|--------|-------|--------|
| **Physical Time** | Простота | Расхождение часов, нет каузальности |
| **Lamport Clock** | Каузальность | Не привязан к реальному времени |
| **Vector Clock** | Полная каузальность | O(N) размер, сложность |
| **HLC (этот пакет)** | Каузальность + близость к времени | Требует синхронизации Update() |

### Best Practices

1. **Выбор Node ID:**
   - Случайный: для динамических кластеров
   - Фиксированный: для статической топологии

2. **Настройка maxDrift:**
   - Локальная сеть: 1-2 минуты
   - WAN: 5-10 минут
   - Использовать NTP для минимизации

3. **Персистентность:**
   - Всегда сохранять состояние при остановке
   - Восстанавливать при запуске

4. **Обработка ошибок:**
   - `ErrFuture`: логировать, возможно отклонить сообщение
   - `ErrClockDrift`: критично, проверить настройки NTP

5. **Использование TID vs Timestamp:**
   - TID: для уникальных идентификаторов записей
   - Timestamp: для точного упорядочивания событий (с LC)

---

## Резюме

Пакет `hlc` предоставляет надежную реализацию гибридных логических часов для:
- ✅ Генерации монотонных временных меток
- ✅ Синхронизации распределенных систем
- ✅ Создания уникальных идентификаторов
- ✅ Обнаружения каузальных связей

**Ключевые преимущества:**
- Thread-safe
- Близость к реальному времени
- Компактное представление (10/8 байт)
- Совместимость с AT Protocol
- Защита от clock drift

**Типичные сценарии использования:**
- Распределенные базы данных
- Event sourcing
- CRDT репликация
- Социальные сети (AT Protocol)
- Микросервисная архитектура
